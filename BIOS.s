37160		;OUP/M BIOS WRITTEN BY SHAO,JIAN-XIONG 
37170		;ON JULY 1982
37180		;ERROR NO. LISTING
37190		;$20 INDEX HOLE FOUND WHILE WRITING
37200		;$21 INDEX HOLE FOUND WHILE READING 
37210		;$22 DRIVE NOT READY
37220		;$23 TRACK NOT MATCH
37230		;$24 DISK WRITING PROTECTION
37240		;$25 I/O DEVICE NOT DEFINED 
37250		;$40 BUFFER AND DISK NOT MATCH 
37260		;$80 PARITY ERROR
37270		*=$E41A 				;OPBIOS START ADDR.
37280		START=$00			
37290		IOBYTE=$03				;I/0 BYTE
37300		COUNTER=$04				;PAGE NO. COUNTER
37310		DEREG=$09				;WORK STORAGES
37320		HLREG=$0B			
37330		HLREG1=$00			
37340		FLAG=$0F			
37350		TEMP=$1F			
37360		IOBFFG=$39				;'FLUSH' FLAG
37370		CRTDSK=$3A				;CURRENT DISK NO.
37380		BLKNB1=$42				;BLOCK#
37390		SECNB1=$43				;SECTOR#
37400		TKNDER=$44				;PREVIOUS TRACK# WHICH THEN 
37410								;CHANGE TO DESIRED TRACK# 
37420		TRKDRC=$45				;DESIRED TRACK#
37430		DMAREG=$46				;DMA ADDRESS
37440		TRKCRN=$48				;HEAD POSITION TRACK#
37450		TKTMAX=$49				;MAX TIMES FOR MATCHING TRACK# 
37460		ERORFG=$4A				;ERROR FLAG
37470		STATFG=$4B				;STATE FLAG
37480		IOBUFA=$4C			
37490		PAGNUB=$4E				;PAGE COUNT
37500		ERTMAX=$4F				;R/W MAX TIMES
37510		DVACIA=$C010			;DISK I/O PORT	
37520		DVPIA1=$C000			;DISK CONTROL	
37530		DVPIA2=$C002			;DISK CONTROL	
37540		CLACIA=$FC00			;CONSOLE I/O PORT	
37550		PTACIA=$CF02			;PRINTER I/O PORT	
37560		SLACIA=$CF00			;SERIAL COMMUNICATION I/O PORT 	
37570		USACI1=$FB03			;USER USING I/O PORT	
37580		USACI2=$F400			;USER USING I/O PORT	
37590		IOBUF=$B000				;DISK I/O BUFFER ADDR. 
37600		CCPSAT=$D000			;CCP ENTRY NO. 1	
37610		CCPST1=$D3F5			;CCP ENTRY NO. 2	
37620		BDOS=$D93F				;BDOS ENTRY
37630		WHBCOT	.BYTE $28			
37640		FRYCST 	.BYTE $62
37650		DKCONT 	.BYTE $40,$00
37660		DIKCRT 	.BYTE $00
37670		PAMTAB 	.WORD DIRBUF,MAPAR0,CHKAR0,$0000 	;DIAK PARA.
37680 			.WORD HIRBUF,MAPAR1,CHKAR1,$0000 	;HEAD TABLE
37690 	; 
37700	;	*****************************************************
37710 	; 	*													*
37720 	; 	*	NUMBER 0 : INITIALIZE INPUT/OUTPUT PORT			*
37730 	; 	*													*
37740 	;	*****************************************************
37750	;
37760 		B00T=*
37770 	;
37780 		LDA 	#$80			;SET IOBYTE TO INDICATE SELECTING 
37790								;PRINTER IN LIST FIELD AND 
37800 		STA 	IOBYTE			;SELECTING CONSOLE IN CONSLE FIELD 
37810 		LDY 	#$00			;SET DVPIA1+1 BIT 2 TO ZERO,INDICAT 	
37820								;DVPIA1 IS DIRECTION REGISTER NOW.	
37830 		STA 	DVPIA1+1					
37840 		LDY 	#$40			;SET DVPIA1 BIT 6 	OUTPUT AND REST 	
37850								;INPUT	
37860		STY		DVPIA1
37870 		LDY 	#$04			;SET BACK INDICATING DVPIA1 IS 	
37880								;CONTROL GATE NOW	
37890 		STY 	DVPIA1+1
37900 		LDA		#$03 			;INITIAIZE CONSOLE PORT	
37910 		STA		CLACIA 			
37920 		LDY		#$11 
37930 		STY		CLACIA 			
37940 		STA		PTACIA 			;INITIALIZE PRINTER PORT 
37950 		STY		PTACIA 
37960 		STA		SLACIA 			;INITIALIZE SERIAL COMMUN. PORT 
37970 		STY		SLACIA 			
37980 		LDA		USACI1+3 		;INITIALIZE USER PORT1
37990 		LDX		#$FF			
38000 		STX		USACI1+2
38010 		LDY		#$00 			;INITIALIZE USER PORT2	
38020 		STY		USACI2+1 
38030 		STY		USACI2 
38040 		STY		USACI2+3 
38050 		STX		USACI2+2 
38060 		LDA		#$04 
38070 		STA		USACI2+1 
38080 		STA		USACI2+3
38090 		RTS
38100 	;
38110 	;	*****************************************************
38120 	;	*													*
38130 	;	* 	NUMBER 1 : WARM BOOT 							*
38140 	;	*													*
38150	; 	*****************************************************
38160	;
38170		WBOOT=*
38180	;
38190		NOP
38200		LDA		#CCPSAT			;SET STARTING ADDR, OF CCP FOR DMA
38210		LDX		#CCPSAT/256
30220		JSR		STDMA1 
38230		LDA		#$00  			;SELECT DRIVE A
38240		STA		DIKCRT
38250		JSR		DIKSEL			
38260		LDA		#$01			;SELECT TRACK 1 
38270		STA		TRKDRC
38280		LDA		#$00			;SELECT SECTOR 00			
38290		STA		SECNB1
38300		LDA		#$10			;SET READ SECTOR FLAG			
38310		STA		FLAG
38320		W$OOT=*					
38330		JSR		RWDBS1			;READ A SECTOR FROM DISK
38340		CLC
38350		LDA		#$80			;NO INCREASE DMAREG TO GET NEXT			
38360								;SECTOR
38370		ADC		DMAREG 			
38380		STA		DMAREG 			
38390		BCC		WB$OT 
38400		INC		DMAREG+1
38410 		WB$OT=*
38420		INC 	SECNB1 			;SET SECTOR NUMBER WITHIN ONE TRACK
38430		LDA 	SECNB1
38440		CMP 	#$1C			;ONE TRACK IS DONE?
38450		BNE 	W$OOT			;IF NOT,KEPT READING 
38460		LDA 	#DFBUFA			;RECOVE DEFAULT BUFFER 
38470		LDX 	#DFBUFA/256
38480		JSR 	STDMA1
38490		LDA 	#$4C 
38500		STA 	START+5 		;SET JMP BDOS AT$05 
38510		STA 	START  			;SET JMP WBOOT AT $00
38520		LDA 	#WBOOT 
38530		STA		START+1 
38540		LDA		#WBOOT/256 
38550		STA		START+2 
38560		LDA		#BDOS 
38570		STA		START+6
38580		LDA		#BDOS/256 
38590		STA		START+7 
38600		LDA		#$00 
38610		STA		IOBFFG
38620		JMP 	CCPSAT
38630	;
38640		C0NTST=*				;CONSOLE TEST FOR RECEIVE READY
38650	;
38660		LDA 	CLACIA 			;TEST BIT 0 OF CLACIA FOR READY
38670		AND 	#$01 
38680		BNE 	C$LTST 
38690		RTS						;IF NOT READY,RETURN WITH A=$00 
38700		C$LTST=* 
38710		LDA		#$FF			;IF READY,RETURN WITH A=$FF
33720		RTS
38730 	;
38740		CONIN=*					;READ A CHARACTER FROM CONSOLE
38750 	;
38760		JSR 	CONTST 			;TEST FOR CONSOLE'S READY,IF NOT
38770		BEQ		CONIN 			;KEPT TESTING
38780		LDA 	CLACIA+1		;IF READY,READ A CHARACTER 
38790		AND 	#$7F			;MASK OFF IT'S BIT 7
38800		RTS
38810	;
38820		CONTOT=*				;CONSOLE TEST FOR TRANSMIT READY 
38830	;
38840		LDA		CLACIA 			;TEST BIT1 OF CLACIA FOR READY 
38850		AND		#$02 
38860		BNE		C$NTOT
38870		RTS 					;IF NOT READY,RETURN WITH A=$00 
38880		C$NTOT=* 
38890		LDA		#$FF			;IF READY,RETURN WITH A=$FF
38900		RTS
38910 	;							
38920		CONOUT=*				;OUTPUT 	A CHARACTER TO CONSOLE
38930	; 							
38940		JSR		CONTOT  		;KEPT TESTING UNTIL IS READY 
38950		BEQ		CONOUT 			
38960		STX		CLACIA+1 		;SENT A CHARACTER TO CONSOLE 
38970		RTS
38980 	;							
38990		PRTTST=*				;PRINTER TEST FOR TRANSMIT READY 
39000 	;							
39010 		LDA		PTACIA			;TEST BIT1 OF PTACIA FOR READY
39020 		AND		#$02
39030 		BNE		P$TTST			
39040 		RTS						;IF NOT READY,RETURN WITH A=$00 
39050 		P$TTST=*				
39060 		LDA 	#$FF			;IF READY, RETURN WITH A=$FF
39070		RTS
39080	;							
39090		PRTOUT=*				;PRINTER OUTPUT
39100	;							
39110		JSR 	PRTTST 			;KEPT TESTING,UNTIL IS READY
39120		BEQ 	PRTOUT 			
39130		STX 	PTACIA+1		;OUTPUT A CHARACTER 
39140		LDA		PTACIA 			;TEST FOR RECEIVING READY 
39150		AND		#$01 
39160		BNE 	P$TOUT			
39170		RTS 	 				;IF NOT,RETURN	
39180		P$TOUT=*					
39190		LDA		PTACIA+1		;IF READY,READ A CHARACTER 
39200		CMP		#$13 			;CONTROL-S
39210		BNE		PR$OUT			;IF NOT CONTROL-S RETURN
39220		RTS 	
39230		PR$OUT=* 				
39240		LDA		PTACIA 			;IF CONTROL-S WAIT UNTL CONTROL-Q 
39250		AND		#$01 			;IS RECEIVED
39260		BEQ		PR$OUT 
39270		CMP		#$11
39280 		BNE 	PR$OUT
39290 		RTS
39300 	;
39310 	SRLTST=*					;SERIAL COMMUN. RECEIVE READY TEST 
39320 	;	
39330 		LDA 	SLACIA			;THE BIT 0 OF SLACIA FOR READY 
39340 		AND 	#$01	
39350		BNE 	S$LTST 			;NOT,RETURN WITH A=$00
39340		RTS	
39370		S$LTST=*	
393S0		LDA 	#$FF 			;READY,RETURN WITH A=$FF
39390		RTS	
39400 	;	
39410		SRLIN=*	
39420	;	
39430		JSR 	SRLTST			;KEPT TESTING,UNTIL IS READY
39440 		BEQ 	SRLIN	
39450 		LDA		SLACIA+1 		;READ A CHARACTER 
39460 		AND		#$7F			;MASK OFF IT'S BIT 7
39470 		RTS	
39480 	;	
39490 		SRLTOT=*				;SERIAL COMMUN. TRANSMIT READY TEST
39500 	;	
39510 		LDA		SLACIA			;TEST BIT 1 OF SLACIA FOR READY
39520 		AND 	#$02	
39530 		BNE 	S$LTOT	
39540 		RTS						;IF NOT,RETURN WITH A=$00 
39550 		S$LTOT=*	
39560 		LDA 	#$FF			;IF READY,RETURN WITH A=$FF
39570 		RTS	
39580 	;	
39590		SRLOUT=*	
39600	;	
39610		JSR	SRLTOT				;KEPT TESTING,UNTIL SLACIA IS 
39620								;READY
39630		BEQ SRLOUT	
39640		STX SLACIA+1			;OUTPUT A CHARACTER
39650		RTS
39660	;
39670	;
39680		OUTBFF=*
39690	;
39700		LDY 	#$00 
39710		OU$BFF=*
39720		LDA 	(DEREG),Y 
39730		CMP 	#$24
39740		BNE 	O$TBFF 
39750		RTS
39760		O$TBFF=*
39770		TAX
39780		JSR 	CONOUT 
39790		INY
39800		BNE 	OU$BFF
39810	;
39820	;
39830	;
39840 	; 	*****************************************************
39850 	; 	*													*
39860 	; 	* NUMBER 2 : 	SAMPLE THE STATUS OF THE CURRENTLY 	*
39870 	; 	*				ASSIGNED CONSOLE DEVICE				*
39880 	; 	*													*
39890	; 	*****************************************************
39900	; 	*													*
39910 	; 	* RETURNED VALUE :									*
39920	; 	*		REGISTER A : $FF READY TO READ				*
39930	; 	*					$00 NOT READY 					*
39940	; 	*													*
39950 	; 	*****************************************************
39960 	;
39970 		CSLTET=*
39980	;
39990 		LDA		IOBYTE			;GET THE CONSLE FIELD OF IOBYTE
40000 		AND 	#$03
40010 		BNE 	C$LTET
40020 		JMP		CONTST			;IF #$00 TO CONSOLE TEST
40030 		C$LTET=*
40040 		CMP		#$01
40050 		BNE		CS$TET
40060 		JMP		PRTTST			;IF #$01 TO PRINT TEST
40070 		CS$TET=*
40080 		CMP 	#$03
40090 		BNE 	CSL$ET
40100		JMP 	USRTST			;IF #$03 TO USER TEST
40110		CSL$ET=*
40120		JMP 	SRLTST			;IF #$02 TO SERIAL TEST
40130 	;
40140 	;	*****************************************************
40150	;	*													*
40160 	;	* NUMBER 3 : READ FROM THE CURRENT ASSIGNED CONSLE	* 
40170 	;	*				DEVICE 								*
40180	;	*													*
40190	;	*****************************************************
40200	;	*													*
40210	;	* RETURNED VALUE : 									*
40220	;	* 	REGISTER A : CHARACTER TO BE READ IN			*
40230	;	*													*
40240	;	*****************************************************
40250	;
40260		CLINN=*
40270	;	
40280		LDA		IOBYTE 			;GET THE CONSOLE FIELD OF IOBYTE
40290		AND		#$03 	
40300		BNE		C$INN 	
40310		CLIN$=*	
40320		JMP 	CONIN 			;IF #$00 TO CONSOLE IN
40330		C$INN=*	
40340		CMP 	#$01 	
40350		BNE 	CL$NN 	
40360		JMP 	SRLIN 			;IF #$01 TO SERIAL COMMUNICATOR IN
40370		CL$NN=*
40380 		CMP		#$03
40390 		BNE		CLIN$ 			;IF #$02 TO CONSOLE IN 
40400 		JMP		USRIN 			;IF #$30 TO USERIN
40410	;
40420 	;	*****************************************************
40430 	;	*													*
40440 	;	* NUMBER 4 :	OUTPUT CHARACTER TO THE CURRENTLY 	*
40450 	;	*				ASSIGNED CONSOLE DEVICES 			*
40460 	;	*													*
40470 	;	*****************************************************
40480 	;	*													*
40490 	;	* ENTRY PARAMETERS 1 								*
40500 	;	*	REGISTER A : CHARACTER TO BE OUTPUT				*
40510 	;	*													*
40520 	;	*****************************************************
40530	;
40540		CLOUTT=*
40550 	;
40560		TAX
40570		LDA 	IOBYTE			;GET CONSOLE FIELD OF IOBYTE
40580		AND 	#$03
40590		BNE		C$OUTT
40600		CLOU$T=*
40610		JMP		CONOUT			;IF #$00 TO CONSLE OUT
40620		C$OUTT=*
40630		CMP		#$01
40640		BNE		CL$UTT
40650		JMP		SRLOUT			;IF #$01 TO SERIAL COMMUNICATON OUT
40660		CL$UTT=*
40670 		CMP 	#$03
40680 		BNE 	CLOU$T			;IF #$02 TO CONSOLE OUT
40690 		JMP 	USROUT			;IF #$03 TO USER OUT
40700 	;
40710 	;	*****************************************************
40720  	;	*													*
40730	;	* NUMBER 5 : 	OUTPUT CHARACTER TO THE CURRENTLY 	*
40740	;	* 				ASSIGNED LIST DEVICE 				*
40750	;	*													*
40760	;	*****************************************************
40770	;	*													*
40780	; 	* ENTRY PARAMETERS : 								*  
40790	;	* 	REGISTER A : CHARACTER TO BE OUTPUT 			* 
40800	;	*													*
40810	;	*****************************************************
40820	;
40830		LITOUT=*
40840	;
40850		TAX
40860		LDA	 	IOBYTE 			;GET LIST FIELD OF IOBYTE
40870		AND	 	#$C0 
40880		BNE	 	L$TOUT 
40890		LITO$T=*
40900		JMP 	CONOUT 			;IF #$00 TO CONSLE OUT
40910		L$T0UT=*
40920		CMP		#$01
40930 		BNE		LI$OUT 
40940 		JMP		SRLOUT			;IF #$01 TO SERIAL COMMUN. OUT
40950		LI$OUT=*
40960 		CMP		#$03
40970 		BEQ		LITO$T			;IF #$03 TO CONSOLE
40980 		JMP		PRTOUT			;IF #$02 TO PRINTER OUT
40990 	;
41000  	;	*****************************************************
41010   ;	*													*
41020	;	* NUMBER 6 : 	OUTPUT A CHARACTER TO THE CURRENTLY	*
41030	;	*				ASSIGNED PUNSH DEVICE				*
41040 	;	*													*
41060	;	*****************************************************
41050	;	*													*
41070 	;	* ENTRY PARAMETERS : 								*
41080	;	*	 REGISTER A : A CHARACTER TO BE OUTPUT 			*
41090	;	*													*
41100	;	*****************************************************
41110	;
41120		PUHOUT=*				;RESERVE FOR FURTHER USE
41130 	;
41140  	;	*****************************************************
41150   ;	*													*
41160 	;	* NUMBER 7 : READ A CHARACTER FROM THE CURRENTYLY 	*
41170 	; 	*			ASSIGNED READER DEVICE 					*
41180  	;	*													*
41190 	;	*****************************************************
41200 	;	*													*
41210 	; 	* RETURNED VALUE : 									*
41220 	; 	* REGISTER A : A CHARACTER BE READ IN				*
41230 	;	*													*
41240	;	*****************************************************
41250	;
41260		READIN=*				;RESERVE FOR FURTHER USE
41270	;
41280		USRTST=* 				;RESERVE FOR FURTHER USE
41290		USROUT=* 				;AS ABOVE
41300		USRIN=*					;AS ABOVE
41310		LDA 	#$25 
41320		JMP 	ERROR
41330	;
41340		DELAYB=*				;DELAY ROUTINE
41350	;
41360		INC		DELYMR 
41370		INC		DELYMR 
41380		INC		DELYMR 
41390		INC		DELYMR
41400		RTS 
41410		DELYMR*=*+1
41420	;
41430	;
41440		DELYMS=*				;DELAY 1 MS
41450	;
41460		JSR 	DELAYB
41470		DEY 
41480		BNE 	DELYMS
41490		RTS
41500	;	
41510		DLYMS1=*				;DELAY (X) MS
41520	;	
41530		LDX 	#$0C	
41540		D$YMS1=*  	
41550		LDY 	FRYCST	
41560		JSR		DELYMS	
41570		DEX 	
41580		BNE 	D$YMS1	
41590		DL$MS1=* 	
41600		RTS	
41610 	;	
41620		DELYUS=*				;DELAY (X)*100 US
41630 	;
41640		LDA		FRYCST 
41650		D$LYUS=*
41660		BIT		$00
41670		SEC
41680		SBC		#$05 
41690		BCS		D$LYUS
41700		DEX
41710		BNE		DELYUS
41720		RTS
41730 	;
41740 	;	*****************************************************
41750 	;	*													*
41760 	;	* NUMBER 8 : POSITION HEAD TO TRACK 0 				*
41770 	;	*													*
41780	;	*****************************************************
41790 	;
41800		HOMEHD=*				;HOME HEAD TO ZERO
41810 	;
41820		JSR		STPIN 
41830		JSR		DLYMS1 
41840		STY		TRKCRN 
41850		STY		TKNDER 
41860		H$MEHD=*
41870		LDA		#$02 
41880		BIT		DVPIA1 
41890		BEQ		DLYMS1 
41900		JSR		STPOUT 
41910		BEQ		H$MEHD
41920	;
41930		ASLDS1=					;(A) * 2'S POWER OF (X)
41940	;
41950		ASL		A
41960		ROL		TEMP 
41970		DEX		
41980		BNE		ASLDS1
41990		RTS		
42000	;
42010		ADCOF1=*
42020	;
42030		CLC 
42040		ADC 	HLREG 
42050		STA 	HLREG 
42060		LDA 	TEMP  
42070		ADC 	HLREG+1  
42080		STA		HLREG+1
42090		RTS
42100 	;
42110		ADCIOF=*
42120 	;
42130		LDX 	#IOBUF 
42140		STX 	HLREG
42150		LDX 	#IOBUF/256  
42160		STX		HLREG+1 
42170 		JMP		ADCOF1
42180 	;
42190 		DIKSEL=					;GET DESIRED DISK PARAMETERS
42200 	;
42210		LDX		DIKCRT 
42220		LDA		DKCONT,X 
42230		STA		DVPIA1 
42240		LDA		#$FF 
42250		STA		DVPIA2
42260		D$KSEL=*
42270		LDA		#$10 
42280		CPX		#$01 
42290		BEQ		DI$SEL 
42300		LDA		#$01
42310		DI$SEL=*
42320		BIT 	DVPIA1 
42330		RTS
42340 	;
42350 	;	*****************************************************
42360	;	*													*
42370 	; 	* NUMBER 9 : SELECT DISK 							*
42380   ;	*													*
42390  	;	*****************************************************
42400  	;	*													*
42410 	; 	* ENTRY PARAMETERS :								*
42420 	;	*	REGISTER A : DISK NUMBER 						*
42430  	;	*													*
42440	;	*****************************************************
42450 	;
42460		DKSEL1=*
42470 	;
42480 		STA		DIKCRT			;STORE DESIRED DISK NO. 
42490 		LDX		#$03			;*8 TO GET OFFSET
42500 		JSR		ASLDS1
42510 		LDX		#PAMTAB
42520 		STX		HLREG
42530 		LDX		#PAMTAB/256








42540 		STX		HLREG+1 
42550 		LDX		#$00 
42560		STX		TEMP
42570 		JSR		ADCOF1 			;GET DESIRED ENTRY ADDR.
42580 		JSR		DIKSEL			;GET PARA. & TEST DISK READY
42590 		BNE		D$SEL1 			
42600		JMP		HOMEHD 			;READY! HOME HEAD
42610		D$SEL1=*				
42620		JMP		TRKPS1			;IF DISK NOT READY,ERR
42630  	;
42640  	;	*****************************************************
42650 	;	*													*
42660 	;	* NUMBER 10 : SET TRACK NUMBER						*
42670   ;	*													*
42680 	;	*****************************************************
42690 	;	*													*
42700	; 	* ENTRY PARAMETERS : 								*
42710	;	* 	REGISTER A : TRACK NUMBER						*
42720  	;	*													*
42730	;	*****************************************************
42740	;
42750 		SETTR1=*
42760	;
42770 		STA 	TRKDRC
42780 		RTS
42790 	;
42800 	;	*****************************************************
42810 	;	*													*
42820	;	* NUMBER 11 : SET SECTOR NUMBER						*
42830   ;	*													*
42840	;	*****************************************************
42850	;	*													*
42860	;	* ENTRY PARAMETERS :								*
42870	;	*	 REGISTER A : SECTOR NUMBER 					*
42880 	;	*													*
42890	;	*****************************************************
42900	;
42910 		SETSC1=*
42920	;
42930 		STA 	SECNB1
42940 		RTS
42950	;
42960	;	*****************************************************
42970	;	*													*
42980	;	* NUMBER 12 : SET BLOCK NUMBER						*
42990   ;	*													*
43000 	;	*****************************************************
43010	;	*													*
43020	;	* ENTRY PARAMETERS :								*
43030	;	*		REGISTER A : BLOCK NUMBER					*
43040 	;	*													*
43050 	;	*****************************************************
43060	;
43070 		SETBL1=*
43080	;
43090		STA		BLKNB1
43100		RTS
43110 	;
43120 	;	*****************************************************
43130 	;	*													*
43140 	;	* NUMBER 13 : SET DMA 								*
43150   ;	*													*
43160 	;	*****************************************************
43170 	;	*													*
43180 	;	* ENTRY PARAMETERS :								*
43190 	;	* 		REGISTER A,X : DMA ADDRESS 			 		*
43200 	;	*													*
43210 	;	*****************************************************
43220	;
43230		STDMA1=*
43240	;
43250		STA		DMAREG 
43260		STX		DMAREG+1
43270		RTS
43280	;	
43290		SEKIHL=*				;SEEK INDEX HOLE
43300	;	
43310		LDA		DVPIA1	
43320		BMI		SEKIHL	
43330		S$KIHL=*	
43340		LDA		DVPIA1	
43350		BPL		S$KIHL	
43360		RTS	
43370	;	
43380		STPOUT=*				;STEP OUT ONE TRACK
43390	;	
43400		LDA		DVPIA2			;SET BIT 2 OF DVPIA2
43410		ORA		#$04 	
43420		BNE		STEP 	
43430		STPIN=*					;STEP IN ONE TRACK 
43440		LDA		#$FB 	
43450		AND		DVPIA2 			;RESET BIT 2 OF DVPIA2
43460		STEP=*	
43470		STA		DVPIA2 			;STEP IN OR OUT ACCORDINGLY 
43480		JSR		DL$MS1 			;DELAY!
43490		AND		#$F7 			;SENT A PULSE TO STEP HEAD
43500		STA		DVPIA2 
43510		JSR		DL$MS1 
43520		JSR		DL$MS1 
43530		ORA		#$08 
43540		STA		DVPIA2 
43550		JSR		DL$MS1 			;DELAY!
43560		LDX		#$08 		
43570		JMP		D$YMS1			;DELAY!
43580	;
43590		SIHSDK=*				;SEEK HOLE ,SET ACIA
43600	;
43610		JSR SEKIHL
43620		LDA		#$03
43630		STA		DVACIA
43640		LDA		#$58
43650		STA		DVACIA
43660		RTS
43670	;
43680		LDHEAD=* 				;LOAD HEAD
43690	;
43700		LDA		#$7F			;RESET BIT 7 OF DVPIA2
43710		AND		DVPIA2
43720		L$HEAD=*
43730		STA		DVPIA2			;LOAD OR UNLOAD HEAD ACCORDINGLY
43740		LDX		#$28 			;DELAY
43750		JMP		D$YMS1
43760	;
43770		UNLDHD=*				;UNLOAD HEAD
43780		LDA		#$80			;SET BIT 7 OF DVAPIA2
43790 		ORA		DVPIA2		
43800		BNE		L$HEAD		
43810	;
43820		WRTDIK=*				;WRITE A BYTE TO DISK 
43830	;
43840		LDA		DVPIA1			;INDEX HOLE FOUND? 
43850		BPL		W$TDIK
43860		LDA		DVACIA 			;READY?
43870		LSR		A
43880		LSR		A
43890		BCC		WRTDIK			;IF NO,KEEP TESTING! 
43900		STX		DVACIA+1		;WRITE A BYTE TO DISK
43910		RTS 
43920		W$TDIK=* 
43930		LDA		#$20			;IF INDEX HOLE FOUND, ERR!
43940		JMP		ERROR
43950	;
43960		REDDIK=*				;READ ABYTE FROM DISK
43970	;
43980		LDA DVPIA1				;INDEX HOLE FOUND? 
43990		BPL R$DDIK				;FOUND, ERROR!
44000		LDA DVACIA 				;READY? 
44010		LSR A
44020		BCC REDDIK				;IF NO, KEEP TESTING 
44030		LDA DVACIA+1			;READ IN A CHAR.
44040		RTS
44050		R$DDIK=*
44060		LDA #$21 				;INDEX HOLE FOUND,ERROR!
44070		JMP ERROR
44080	;
44090		TRKPSA=*				;PUT HEAD TO DESIRED TRACK 
44100	;
44110		LDX		DIKCRT			;DESIRED DISK READY? 
44120		JSR		D$KSEL 
44130		BEQ		T$KPSA 
44140		TRKPS1=*
44150		LDA		#$22			;NOT READY,ERROR!
44160 		JMP		ERROR
44170 		T$KPSA=*
44180 		LDA		TKNDER 			;CURRENT DESIRED TRACK = 
44190		CMP		TRKCRN			;CURRENT HEAD POSITION?
44200		BEG		TR$PSA			;IF EQUAL, FINISH STEPIN6
44210		BCS		TRK$SA			;IF GREATER,STEP IN ONE TRACK
44220		JSR		STPOUT			;OIF LESS,STEP OUT ONE TARACK
44230		LDA		#$99 			;AND SET 'A' TO 99 INDICATING
44240		BCC		TRKP$A			;SUBTRACTING ONE TRACK
44250		TRK$SA=*
44260		JSR STPIN
44270 		TXA 
44280 		TRKP$A=* 
44290 		SED
44300		ADC		TRKCRN			;+ (OR -) ONE TO (OR FROM) 
44310 		STA		TRKCRN			;CURRENT HEAD POSITION
44320 		CLD	
44330 		JMP		T$KPSA			;KEEP STEPIN6 UNTIL DONE
44340 		TR$PSA=*
44350 		CMP		#$43 			;CHECK CURRENT TRACK RANGE 
44360 		LDA		DVPIA2			;IF IN NO.43-76, RESET BIT 7  
44370 		AND		#$BF 			;OF DVPIA2 TO ADJUST CURRENT
44380 		LDY		#$00
44390		NOP
44400		BCS		TRKPS$ 
44410		LDA		#$40 			;IF IN NO.0-42, SET BIT 7 
44420		ORA		DVPIA2			;OF DVACIA
44430		TRKPS$=* 
44440		STA		DVPIA2
44450		RTS
44460	;
44470		TRKPSH=*
44480	;
44490		JSR		TRKPSA			;POSITION HEAD
44500		LDA		#IOBUF			;SET DISK I/O BUFFER ADDR.
44510		STA		IOBUFA
44520		LDA		#IOBUF/256
44530 		STA		IOBUFA+1
44540 		JMP		LDHEAD			;LOAD HEAD
44550	;
44560		TKNMTH=*				;MATCH TRACK#
44570	;
44580		LDA		#$05 			;SET MAX. TRACK READ TIMES
44590		STA		TKTMAX 
44600		TKNM$H=*
44610		JSR		SIHSDK			;SEEK INDEX HOLE, SET DVACIA 
44620		T$NMTH=*
44630		JSR		REDDIK			;READ A BYTE INTO 'A' 
44640		TK$MTH=*
44650		CMP		#$43 			;FIND TRACK IDENTIFICATION 
44660		BNE		T$NMTH			;NO. $43 & $57 
44670		JSR		REDDIK 
44680		CMP		#$57
44690 		BNE		TK$MTH
44700		JSR 	REDDIK 			;CHECK TRACK NO.
44710		CMP		TKNDER 
44720		BNE		TKN$TH
44730		RTS						;IF MATCH,RETURN!
44740		TKN$TH=*				;IF NOT,HOME HEAD AND TRY AGAIN
44750		DEC		TKTMAX 			;MAX, TIME EXCEED?
44760		BEQ		TKNMT$ 
44770		LDA		TKNDER			;NO? SAME CURRENT DESIRED NO. 
44730		PHA	
44790		JSR		HOMEHD			;HOME HEAD!
44SOO		PLA	
44810		STA		TKNDER 			;RECOVE TRACK NO. 
44820		JSR		T$KPSA 			;POSITION HEAD AGAIN 
44830		JMP		TKNM$H			;MATCHT THEM AGAIN!
44840		TKNMT$=*
44850		LDA		#$23 			;MAX, EXHAUSTED, ERROR!
44860		JMP		ERROR
44870	;
44880 		WRTTKS=*				;WRITE A TRACK TO DISK 
44890 	;
44900		LDA		#$20 			;INDEX HOLE FOUND!
44910		BIT		DVPIA1 
44920		BNE		W$TTKS 
44930		LDA		#$24 			;IF FOUND, ERROR!
44940		JMP		ERROR
44950		W$TTKS=*
44960		JSR		TKNMTH 			;CHECK IF TRACK NO, ARE MATCHED 
44970		LDX		#$04 			;DELAY!
44980		JSR		DELYUS 
44990		LDA		#$FE 			;ENABLE ERASING
45000		AND		DVPIA2
45010		STA		DVPIA2
45020		LDX		#$02			;DELAY!
45030		JSR		DELYUS
45040		LDA		#$FD			;ENABLE WRITING
45050		AND		DVPIA2
45060		STA		DVPIA2
45070		LDX		#$08			;DELAY!
45080		JSR		DELYUS			
45090		LDX		#$76			;WRITE START FLAG $76 
45100		JSR		WRTDIK			
45110		LDX		#$0E			;SET 14 PAGES
45120		STX		PAGNUB			
45130		LDY		#$00
45140		WR$TKS=*
45150		LDA		(IOBUFA),Y		;GET A BYTE FROM DISK I/O 
45160		TAX						;BUFFER AND WRITE IT
45170		JSR		WRTDIK			;TO THE DISK
45180 		INY				
45190		BNE		WR$TKS
45200		INC		IOBUFA+1
45210		DEC		PAGNUB			;KEEP DOING UNTIL 14 PAGE DONE 
45220		BNE		WR$TKS			
45230		LDX		#$47			;WRITE END FLAG
45240 		JSR		WRTDIK
45250 		LDX		#$53 
45260 		JSR 	WRTDIK
45270		LDA 	DVPIA2			;DISABLE WRITING
45280 		ORA 	#$01 
45290		STA 	DVPIA2
45300		LDX 	#$05			;DELAY!
45310		JSR 	DELYUS
45320		LDA		DVPIA2 			;DISABLE ERASING
45330		ORA		#$02 
45340		STA		DVPIA2
45350		LDA		#I0BUF/256
45360		STA		IOBUFA+			;RECOVE I/O BUFFER ADDR,1
45370		RTS
45380	;
45390		REDTKS=*				;READ A TRACK
45400 	;
45410		JSR		TKNMTH			;MATCH TRACK NO.
45420		R$DTKS=*
45430		JSR		REDDIK 			;FIND DATA AREA START FLAG
45440		CMP		#$76 
45450		BNE		R$DTKS 
45460		LDX		#$0E 			;SET TOTAL PAGE NO. 14 
45470		LDY		#$00 
45480		STY		ERORFG 			;INIT ERR FLAG
45490		LDA		#$01
45500		RE$TKS=*
45510		BIT		DVACIA 			;READY?
45520		BEQ		RE$TKS 
45530		LDA		DVACIA+			;READ A BYTE 
45540		BVC		RED$KS 			;PARITY ERR?
45550		LDA		#$80 			;IF IS, SET ERR FLAG
45560		STA		ERORFG
45570		R$$TKS=*
45580		CLC						;RESET CARRY TO INDICATE ERR
45590		RTS
45600		RED$KS=*
45610		BIT		STATFG		
45620		BPL		REDTK$		
45630		CMP		(IOBUFA),Y		;YES, COMPARE IT WITH THE ONE	
45640		BEQ		REDTK$			;IN THE I/O BUFFER READ IN BEFORE
45650		LDA		#$40			;IF NOT, SET ERR FLAG 
45660		STA		ERORFG 
45670		BNE		R$$TKS
45680		REDTK$=*			
45690		STA		(IOBUFA),Y
45700		LDA		#$01
45710		INY					
45720		BNE		RE$TKS 			;ONE PAGE DONE?
45730		INC		IOBUFA+			;YES, INCREAMENT HIGH BYTE		
45740		DEX		
45750		BNE		RE$TKS			;14 PAGE DONE?
45760		LDA		#IOBUF/256 
45770		STA		IOBUFA+1		;RECOVE I/O BUFFER ADDR.
45780		SEC						;SET CARRY INDICATING NO ERR
45790		RTS			
45800	;			
45810		WRTTRK=*				;WRITE A TRACK UTILL NO ERROR
45S20	;
45830		LDA		#$A0			;SET NO REREAD MODE
45840		STA		STATFG
45850		JSR		TRKPSH			;POSITION HEAD TO DESIRED TRACK
45860		LDA		#$04			;SET MAX. WRITE TIMES
45870		STA		ERTMAX+1
45880		W$TTRK=*		
45890		JSR		WRTTKS			;WRITE A TRACK
45900		JMP		RE$TRK			;GO TO REREAD MODE TO CHECK
45910	;			
45920		REDTRK=*				;;READ A TRACK UNTIL NO ERROR
45930	;
45940		LDA		#$40 			;SET NO REREAD MODE
45950		STA		STATFG 	
45960		JSR		TRKPSH 			;POSITION HEAD TO DESIRED TRACK
45970		LDA		#$04 	
45980		STA		ERTMAX 	
45990		RE$TRK=*	
46000		LDA		#$06 	
46010		STA		ERTMAX+2	
46020		REDT$K=*	
46030		JSR		REDTKS			;READ A TRACK	
46040		BCC		REREAD			;IF ERR, GO TO ERR HANDLING 	
46050		BIT		STATFG			;REREAD MODE/?	
46060		BMI		R$DTRK	
46070		LDA		#$80 			;IF NOT, SET FLAG TO INDICATE 	
46080		ORA		STATFG			;NOW IS IN REREAD MODE	
46090		STA		STATFG	
46100		BNE		RE$TRK			;AND GO BACK TO REREAD! 
46110		R$DTRK=*	
46120		JMP		UNLDHD			;IF IS REREAD,UNLOAD HEAD, FINISH
46130		NOP		
46140		REREAD=*				;ERR HANDLING
46150		LDA		#I0BUF/256 	
46160		STA		IOBUFA+1 	
46170		DEC		ERTMAX+2 	
46180		BNE		REDT$K 	
46190		BIT		ERORFG 	
46200		BMI		RE$EAD 
46210		BIT		STATFG
46220		BV3		R$READ
46230		DEC		ERTMAX+1
46240		BNE		W$TTRK
46250		R$READ=*
46260		LDA		ERORFG
46270		JMP		ERROR 
46280		RE$EAD=*
46290		DEC		ERTMAX
46300		BEQ		R$READ
46310		JSR		STPOUT
46320		JSR		DLYMS1
46330		JSR		STPIN
46340		JSR		DLYMS1
46350		BEQ		RE$TRK
46360		RESV27*=*+5
46370 	;
46380 	;	*****************************************************
46390 	;	*													*
46400 	;	* NUMBER 14 : READ/WRITE B/S FROM/TO DISK 			*
46410 	;	*													*
46420	;	*****************************************************
46430 	;
46440 		RWDBS1=*				;READ/WRITE B/S FROM/TO DISK 
46450 	;
46460		LDA		TKNDER 			;TRACK 0?
46470		BEQ		RWDB$$ 
46480		CMP		TRKDRC 			;DESIRED TRACK = CURRENT TRACK? 
46490		BEQ		R$DBS1 			;YES, NO DISK I/O
46500		BIT		IOBFFG 			;'FLUSH' FLAG SET?
46510		BPL		RWDB$$			;IF NO, NO WRITING BACK
46520		JSR		WRTTRK			;WRITE BACK TO CURRENT TRACK
46530		RWDB$$=*
46540		LDA		TRKDRC 			;STORE DESIRED NO, TO CURRENT NO.
46550		STA		TKNDER 
46560		JSR		REDTRK			;READ THIS TRACK 
46570		LDA		#$00 			;FLUSH 'FLUSH' FLAG
46580		STA		IOBFFG
46590		R$DBS1=*
46600		BIT		FLAG			;WRITE OR READ?
46610		BVC		RWD$$$
46620		LDA		#$80			;IF WRITE? SET 'FLUSH' FLSA6
46630		STA		IOBFFG
46640		RWD$$$=*
46650		NOP
46660		NOP
46670		NOP
46680		NOP
46690		NOP
46700		LDA		DMAREG 			;SENT DMA ADDR. TO HLREG1
46710		STA		HLREG1 
46720		LDA		DMAREG+1 
46730		STA		HLREG1+1 
46740		LDY		#$00 
46750		STY		TEMP 
46760		LDA		#$10 			;SECTOR OPERATION?
46770		BIT		FLAG 
46780		BEQ		RE$BS1 
46790		LDA		SECNB1			;YES? READ OR WRITE A SECTOR 
46800		LDX		#$07 			;BETWEEN DISK I/O BUFFER AND DMA
46810		JSR		ASLDS1 
46820		JSR		ADCIOF
46830		RED$S1=*
46840		BIT		FLAG
46850		BVS		REDBS$
44360		LDA		(HLREG),Y
46S70		STA		(HLREG1),Y
46830		JMP		R$$BS1
46890		REDBS$=*
46900		LDA 	(HLREG1),Y 
46910		STA 	(HLREG),Y 
46920		RIIBS1=*
46930		INY	
46940		CPY		#$80
46950		BNE		RED$S1
46960		RTS		
46970		RE$BS1=*
46980		LDA		BLKNB1 			;IF IS BLOCK OPERATION, READ 
46990		LDX		#$09 			;OR WRITE A BLOCK BETWEEN 
47000		JSR		ASLDS1 			;DISK I/O BUFFER AND DMA
47010		JSR		ADCIOF
47020		LDX		#$02 
47030		REDB$1=*
47040		BIT		FLAG
47050		BVS		RE$$S1
47060		LDA		(HLREG),Y
47070		STA		(HLREG1),Y
47080		JMP		REB$$1
47090		RE$$S1=*
47100		LDA		(HLREG1),Y
47110		STA		(HLREG),Y
47120		REB$$1=*
47130		INY		
47140		BNE		REDB$1
47150		INC		HLREG+1
47160		INC		HLREG1+1
47170		DEX		
47180		BNE		REDB$1
47190		RTS		
47200		RESV28*=*+5
47210	;
47220		S$OBDK=*				;SENT I/O BUFFER BACK TO DISK
47230	;
47240		BIT 	IOBFFG 			;'FLUSH' FLAG SET?
47250		BPL 	S$OBDK
47260		JSR 	WRTTRK 			;IF SET, WRITE BACK TO DISK
47270		LDA 	*$00 
47280		STA 	IOBFFG 
47290		S$OBDK=*
47300		RTS 
47310	;
47320		BCDASC=*				;CONVERT BCD TO TWO ASCII CODES
47330	;
47340		PHA	
47350		AND 	#$OF			;GET LOW NIBBLE
47360		CLC	
47370		ADC 	#$30 			;CONVERT TO ASCII CODE
47380		TAY	
47390		PLA
47400		LSR		A
47410		LSR		A
47420		LSR		A
47430		LSR		A
47440		AND		#$0F			;GET HIGH NIBB1E 
47450		CLC	
47460		ADC		#$30			;CONVERT TO ASCII CODE
47470		RTS
47480 	;
47490 	;	*****************************************************
47500 	;	*													*
47510 	;	*	NUMBER 15 : ERROR HANDLING						*
47520 	;	*													*
47530 	;	*****************************************************
47540 	;	*													*
47550 	;	* ENTRY PARAMETERS :								*
47560 	;	*		REGISTER A : ERROR NUMBER					*
47570 	;	*													*
47530 	;	*****************************************************
47590	;
47600		ERROR=*
47610	;
47620		JSR BCDASC 				;CONVERT ERR NO. TO 2 ASCII 	
47630		LDX #$0B	 			;AND INSERT THEM TO THE ERR 	
47640		STA EROR,X 				;MESSA6E	
47650		INX	
47660		TYA	
47670		STA	EROR,X 
47680		LDA	CRTDSK				;CONVERT CURRENT DISK NO.TO 
47690		CLC						;ASCII AND INSERT IT TO THE 			
47700		ADC	#$41 				;ERR MESSAGE				
47710		LDX	#$16		
47720		STA	EROR,X 	
47730		LDA	#EROR 				;OUTPUT ERR MESSAGE
47740		STA	DEREG 
47750		LDA	#EROR/256
47760		STA DEREG+1	
47770		JSR OUTBFF	
47780		JMP CCPST1
47790		EROR .BYTE ' 	OPST ERR 	ON DISK 	$'
47800	;
47810		DFBUFA*=*+512 			;DEFAULT BUF 
47820		DIRBUF*=*+512 			;DIRECTORY BUF
47830		MAPAR0*=*+64 			;MAP AREA OF DISK A 
47840		MAPAR1*=*+64 			;MAP AREA OF DISK B 
47850		CHKAR0*=*+14 			;CHECK AREA OF DISK A 
47860		CHKAR1*=*+14 			;CHECK AREA OF DISK B 
47870		FLCTBK*=*+35			;FILE CONTROL BLOCK
